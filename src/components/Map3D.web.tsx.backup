import React, { useEffect, useRef, useState } from "react";
import { Activity } from "../types";

interface Map3DProps {
  activities: Activity[];
  nearbyActivities: Activity[];
  userLocation: { latitude: number; longitude: number } | null;
  selectedActivity: Activity | null;
  onSelectActivity: (activity: Activity) => void;
  onViewActivity: (activity: Activity) => void;
  RADIUS_KM: number;
}

// This component renders an isometric city-style map
export const Map3D: React.FC<Map3DProps> = ({
  activities,
  nearbyActivities,
  userLocation,
  selectedActivity,
  onSelectActivity,
  onViewActivity,
  RADIUS_KM,
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const sceneRef = useRef<any>(null);
  const cameraRef = useRef<any>(null);
  const rendererRef = useRef<any>(null);
  const cityGroupRef = useRef<any>(null);
  const markerGroupRef = useRef<any>(null);
  const raycasterRef = useRef<any>(null);
  const mouseRef = useRef<any>(null);
  const [isInitialized, setIsInitialized] = useState(false);
  const panRef = useRef({ x: 0, z: 0 });

  const selectedActivityRef = useRef<Activity | null>(null);
  const onSelectActivityRef = useRef<(activity: Activity) => void>(() => {});
  const onViewActivityRef = useRef<(activity: Activity) => void>(() => {});

  useEffect(() => {
    selectedActivityRef.current = selectedActivity;
  }, [selectedActivity]);

  useEffect(() => {
    onSelectActivityRef.current = onSelectActivity;
  }, [onSelectActivity]);

  useEffect(() => {
    onViewActivityRef.current = onViewActivity;
  }, [onViewActivity]);

  useEffect(() => {
    if (!containerRef.current || isInitialized) {
      console.log("[Map3D] Skipping init", {
        hasContainer: !!containerRef.current,
        isInitialized,
      });
      return;
    }

    console.log("[Map3D] Starting initialization check...");

    // Add a small delay to ensure container has dimensions
    const timer = setTimeout(() => {
      const width = containerRef.current?.clientWidth || 0;
      const height = containerRef.current?.clientHeight || 0;

      console.log("[Map3D] Container dimensions:", { width, height });

      if (width > 0 && height > 0) {
        console.log("[Map3D] Dimensions valid, attempting Three.js import...");

        // Dynamically import Three.js only on web
        import("three")
          .then((module) => {
            console.log("[Map3D] Three.js imported successfully:", {
              hasScene: !!module.Scene,
            });
            const THREE = module;
            initializeScene(THREE, containerRef.current!);
            setIsInitialized(true);
          })
          .catch((err) => {
            console.error("[Map3D] Failed to import Three.js:", err);
          });
      } else {
        console.warn("[Map3D] Container does not have valid dimensions yet", {
          width,
          height,
        });
        // Try again
        setTimeout(() => {
          console.log("[Map3D] Retrying after delay...");
          if (
            containerRef.current?.clientWidth &&
            containerRef.current?.clientHeight
          ) {
            import("three")
              .then((module) => {
                console.log("[Map3D] Three.js imported successfully (retry)");
                const THREE = module;
                initializeScene(THREE, containerRef.current!);
                setIsInitialized(true);
              })
              .catch((err) =>
                console.error("[Map3D] Import failed (retry):", err),
              );
          }
        }, 500);
      }
    }, 100);

    return () => clearTimeout(timer);
  }, [isInitialized]);

  // Update markers when activities change
  useEffect(() => {
    if (!markerGroupRef.current || !userLocation || !sceneRef.current) return;

    // Clear existing markers
    markerGroupRef.current.clear();

    import("three").then((THREE) => {
      const categoryColors: { [key: string]: number } = {
        Outdoor: 0xff6b6b,
        Sports: 0xffd93d,
        Fitness: 0x6bcb77,
        Social: 0x4d96ff,
        Learning: 0x9d84b7,
        Arts: 0xf4a261,
        Other: 0x95a5a6,
      };

      // Add user location marker
      const userMarkerGeometry = new THREE.ConeGeometry(3, 10, 8);
      const userMarkerMaterial = new THREE.MeshStandardMaterial({
        color: 0x007aff,
        roughness: 0.35,
        metalness: 0.25,
      });
      const userMarker = new THREE.Mesh(userMarkerGeometry, userMarkerMaterial);
      userMarker.position.set(0, 0, 0);
      userMarker.castShadow = true;
      userMarker.userData = {
        kind: "user",
        baseY: 0,
        phase: Math.random() * 6.28,
      };
      markerGroupRef.current.add(userMarker);

      const userRingGeometry = new THREE.RingGeometry(8, 12, 64);
      const userRingMaterial = new THREE.MeshBasicMaterial({
        color: 0x2f80ff,
        transparent: true,
        opacity: 0.18,
        side: THREE.DoubleSide,
      });
      const userRing = new THREE.Mesh(userRingGeometry, userRingMaterial);
      userRing.rotation.x = -Math.PI / 2;
      userRing.position.set(0, 0.1, 0);
      userRing.userData = { kind: "pulse" };
      markerGroupRef.current.add(userRing);

      // Add activity markers
      nearbyActivities.forEach((activity) => {
        if (!activity.latitude || !activity.longitude || !userLocation) return;

        // Calculate distance and position
        const R = 6371; // Earth's radius in km
        const dLat =
          ((activity.latitude - userLocation.latitude) * Math.PI) / 180;
        const dLon =
          ((activity.longitude - userLocation.longitude) * Math.PI) / 180;
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos((userLocation.latitude * Math.PI) / 180) *
            Math.cos((activity.latitude * Math.PI) / 180) *
            Math.sin(dLon / 2) *
            Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        const distance = R * c;

        const normalizedDistance = Math.min(distance / RADIUS_KM, 1);
        const angle = Math.atan2(
          activity.longitude - userLocation.longitude,
          activity.latitude - userLocation.latitude,
        );

        // Scale to fit within visible area (0-150 units from center)
        const maxDist = 150;
        const x = Math.max(
          -maxDist,
          Math.min(maxDist, normalizedDistance * maxDist * Math.cos(angle)),
        );
        const z = Math.max(
          -maxDist,
          Math.min(maxDist, normalizedDistance * maxDist * Math.sin(angle)),
        );
        const y = 15;

        // Create marker as sphere
        const markerGeometry = new THREE.SphereGeometry(2, 32, 32);
        const color = categoryColors[activity.category] || categoryColors.Other;
        const markerMaterial = new THREE.MeshStandardMaterial({
          color,
          roughness: 0.4,
          metalness: 0.6,
        });

        const marker = new THREE.Mesh(markerGeometry, markerMaterial);
        marker.position.set(x, y, z);
        marker.castShadow = true;
        marker.receiveShadow = true;
        marker.userData = {
          kind: "activity",
          activity,
          baseY: y,
          phase: Math.random() * 6.28,
        };

        // Add a subtle vertical beam (Pokemon Go-ish)
        const beamGeometry = new THREE.CylinderGeometry(0.5, 0.5, 60, 8);
        const beamMaterial = new THREE.MeshBasicMaterial({
          color,
          transparent: true,
          opacity: 0.15,
        });
        const beam = new THREE.Mesh(beamGeometry, beamMaterial);
        beam.position.set(x, y + 30, z);
        beam.userData = {
          kind: "beam",
          baseY: y + 30,
          phase: marker.userData.phase,
        };
        markerGroupRef.current!.add(beam);

        // Add glow for selected activity
        if (selectedActivity?.id === activity.id) {
          const glowGeometry = new THREE.SphereGeometry(3, 32, 32);
          const glowMaterial = new THREE.MeshBasicMaterial({
            color,
            transparent: true,
            opacity: 0.3,
          });
          const glow = new THREE.Mesh(glowGeometry, glowMaterial);
          glow.position.copy(marker.position);
          glow.userData = {
            kind: "glow",
            baseY: y,
            phase: marker.userData.phase,
          };
          markerGroupRef.current!.add(glow);
        }

        markerGroupRef.current!.add(marker);
      });
    });
  }, [nearbyActivities, selectedActivity, userLocation, RADIUS_KM]);

  const initializeScene = (THREE: any, container: HTMLDivElement) => {
    console.log("[Map3D] initializeScene called", {
      width: container.clientWidth,
      height: container.clientHeight,
      hasThree: !!THREE,
    });

    if (!container.clientWidth || !container.clientHeight) {
      console.error("[Map3D] Container has invalid dimensions");
      return;
    }

    // Scene setup
    const scene = new THREE.Scene();
    console.log("[Map3D] Scene created");
    scene.background = new THREE.Color(0x87ceeb);
    scene.fog = new THREE.Fog(0x87ceeb, 300, 1000);

    // Camera setup
    const width = container.clientWidth;
    const height = container.clientHeight;

    if (width <= 0 || height <= 0) {
      console.error("Container has invalid dimensions:", { width, height });
      return;
    }

    const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 2000);
    camera.position.set(0, 120, 180);
    camera.lookAt(0, 0, 0);

    // Initialize rotation based on camera position
    const dist = Math.sqrt(camera.position.x ** 2 + camera.position.z ** 2);
    rotationRef.current.y = Math.atan2(camera.position.x, camera.position.z);
    rotationRef.current.x = Math.atan2(camera.position.y - 0, dist);

    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(width, height);
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    console.log("[Map3D] Renderer created, appending to container...");
    container.appendChild(renderer.domElement);
    console.log("[Map3D] Renderer DOM element appended successfully");

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(100, 200, 100);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.near = 10;
    directionalLight.shadow.camera.far = 600;
    directionalLight.shadow.camera.left = -200;
    directionalLight.shadow.camera.right = 200;
    directionalLight.shadow.camera.top = 200;
    directionalLight.shadow.camera.bottom = -200;
    scene.add(directionalLight);

    // Ground plane
    const groundGeometry = new THREE.PlaneGeometry(600, 600, 60, 60);
    const groundMaterial = new THREE.MeshStandardMaterial({
      color: 0x4a9f6b,
      roughness: 0.9,
      metalness: 0.05,
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    ground.receiveShadow = true;
    scene.add(ground);

    // Add some subtle height variation
    const positions = groundGeometry.attributes.position;
    for (let i = 0; i < positions.count; i++) {
      const z = positions.getZ(i);
      positions.setZ(i, z + Math.random() * 3 - 1.5);
    }
    groundGeometry.computeVertexNormals();

    const gridHelper = new THREE.GridHelper(600, 60, 0xffffff, 0xffffff);
    const gridMaterials = Array.isArray((gridHelper as any).material)
      ? (gridHelper as any).material
      : [(gridHelper as any).material];
    gridMaterials.forEach((m: any) => {
      m.transparent = true;
      m.opacity = 0.06;
    });
    gridHelper.position.y = 0.1;
    scene.add(gridHelper);

    // Marker group
    const markerGroup = new THREE.Group();
    scene.add(markerGroup);

    sceneRef.current = scene;
    cameraRef.current = camera;
    rendererRef.current = renderer;
    terrainRef.current = ground;
    markerGroupRef.current = markerGroup;
    raycasterRef.current = new THREE.Raycaster();
    mouseRef.current = new THREE.Vector2();

    // Handle mouse click for raycasting
    const onMouseClick = (event: MouseEvent) => {
      const rect = renderer.domElement.getBoundingClientRect();
      const w = rect.width || width;
      const h = rect.height || height;
      mouseRef.current.x = ((event.clientX - rect.left) / w) * 2 - 1;
      mouseRef.current.y = -((event.clientY - rect.top) / h) * 2 + 1;

      raycasterRef.current.setFromCamera(mouseRef.current, camera);
      const intersects = raycasterRef.current.intersectObjects(
        markerGroup.children,
      );

      if (intersects.length > 0) {
        const marker = intersects[0].object as any;
        const activity = marker?.userData?.activity;
        if (activity) {
          if (selectedActivityRef.current?.id === activity.id) {
            onViewActivityRef.current(activity);
          } else {
            onSelectActivityRef.current(activity);
          }
        }
      }
    };

    renderer.domElement.addEventListener("click", onMouseClick);

    // Camera controls
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };

    const onMouseDown = (event: MouseEvent) => {
      isDragging = true;
      previousMousePosition = { x: event.clientX, y: event.clientY };
    };

    const onMouseMove = (event: MouseEvent) => {
      if (!isDragging) return;

      const deltaX = event.clientX - previousMousePosition.x;
      const deltaY = event.clientY - previousMousePosition.y;

      const rotation = rotationRef.current;
      rotation.y += deltaX * 0.005;
      rotation.x -= deltaY * 0.005;

      // Clamp vertical rotation
      rotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 2.5, rotation.x));

      const distance = Math.sqrt(
        camera.position.x ** 2 +
          camera.position.y ** 2 +
          camera.position.z ** 2,
      );

      camera.position.x =
        distance * Math.sin(rotation.y) * Math.cos(rotation.x);
      camera.position.y = distance * Math.sin(rotation.x);
      camera.position.z =
        distance * Math.cos(rotation.y) * Math.cos(rotation.x);
      camera.lookAt(0, 0, 0);

      previousMousePosition = { x: event.clientX, y: event.clientY };
    };

    const onMouseUp = () => {
      isDragging = false;
    };

    const onWheel = (event: WheelEvent) => {
      event.preventDefault();
      const distance = Math.sqrt(
        camera.position.x ** 2 +
          camera.position.y ** 2 +
          camera.position.z ** 2,
      );
      const newDistance = Math.max(
        60,
        Math.min(400, distance + event.deltaY * 0.2),
      );
      const ratio = newDistance / distance;
      camera.position.x *= ratio;
      camera.position.y *= ratio;
      camera.position.z *= ratio;
    };

    renderer.domElement.addEventListener("mousedown", onMouseDown);
    renderer.domElement.addEventListener("mousemove", onMouseMove);
    renderer.domElement.addEventListener("mouseup", onMouseUp);
    renderer.domElement.addEventListener("wheel", onWheel, { passive: false });

    // Animation loop
    let animationId: number;
    const animate = () => {
      animationId = requestAnimationFrame(animate);

      // Subtle motion to keep things "alive"
      const t = performance.now() / 1000;
      if (markerGroupRef.current) {
        markerGroupRef.current.children.forEach((obj: any) => {
          const kind = obj?.userData?.kind;
          if (!kind) return;

          const phase = obj.userData.phase ?? 0;
          const baseY = obj.userData.baseY ?? obj.position.y;

          if (kind === "activity") {
            obj.position.y = baseY + Math.sin(t * 1.2 + phase) * 0.8;
          } else if (kind === "beam") {
            obj.position.y = baseY + Math.sin(t * 0.9 + phase) * 0.6;
            obj.material.opacity = 0.12 + Math.sin(t * 1.5 + phase) * 0.04;
          } else if (kind === "glow") {
            const scale = 1 + Math.sin(t * 2 + phase) * 0.12;
            obj.scale.setScalar(scale);
          } else if (kind === "pulse") {
            const s = 1 + Math.sin(t * 1.4) * 0.1;
            obj.scale.setScalar(s);
            obj.material.opacity = 0.14 + Math.sin(t * 1.4) * 0.04;
          }
        });
      }

      renderer.render(scene, camera);
    };
    animate();
    console.log("[Map3D] Animation loop started, rendering should begin now");

    // Handle resize
    const handleResize = () => {
      const newWidth = container.clientWidth || width;
      const newHeight = container.clientHeight || height;
      camera.aspect = newWidth / newHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(newWidth, newHeight);
    };

    window.addEventListener("resize", handleResize);

    return () => {
      console.log("Cleaning up 3D scene");
      cancelAnimationFrame(animationId);
      window.removeEventListener("resize", handleResize);
      renderer.domElement.removeEventListener("click", onMouseClick);
      renderer.domElement.removeEventListener("mousedown", onMouseDown);
      renderer.domElement.removeEventListener("mousemove", onMouseMove);
      renderer.domElement.removeEventListener("mouseup", onMouseUp);
      renderer.domElement.removeEventListener("wheel", onWheel);
      if (container.contains(renderer.domElement)) {
        container.removeChild(renderer.domElement);
      }

      // Dispose renderer and materials
      renderer.dispose();
      if (ground) {
        ground.geometry?.dispose();
        if (Array.isArray(ground.material)) {
          ground.material.forEach((m: any) => m?.dispose());
        } else {
          ground.material?.dispose();
        }
      }
    };
  };

  return (
    <div
      ref={containerRef}
      style={{
        width: "100%",
        height: "100%",
        position: "relative",
        overflow: "hidden",
        backgroundColor: "#87ceeb",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
      }}
    >
      {!isInitialized && (
        <div
          style={{
            textAlign: "center",
            color: "#666",
            fontSize: "16px",
            fontFamily:
              "Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif",
          }}
        >
          <div>üìç Loading 3D Map...</div>
          <div style={{ fontSize: "12px", marginTop: "8px", color: "#999" }}>
            Container: {containerRef.current?.clientWidth || 0}x
            {containerRef.current?.clientHeight || 0}px
          </div>
        </div>
      )}
    </div>
  );
};

function generateLowPolyTerrain(
  THREE: any,
  width: number,
  height: number,
  scale: number,
): any {
  const geometry = new THREE.BufferGeometry();

  const verticesArray: number[] = [];
  const indicesArray: number[] = [];

  const cols = Math.floor(width / 20);
  const rows = Math.floor(height / 20);

  // Generate vertices
  for (let i = 0; i <= rows; i++) {
    for (let j = 0; j <= cols; j++) {
      const x = (j / cols) * width - width / 2;
      const z = (i / rows) * height - height / 2;
      const y = Math.random() * scale - scale / 2;

      verticesArray.push(x, y, z);
    }
  }

  // Generate indices
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      const a = i * (cols + 1) + j;
      const b = a + cols + 1;
      const c = a + 1;
      const d = b + 1;

      indicesArray.push(a, b, c);
      indicesArray.push(c, b, d);
    }
  }

  geometry.setAttribute(
    "position",
    new THREE.BufferAttribute(new Float32Array(verticesArray), 3),
  );
  geometry.setIndex(
    new THREE.BufferAttribute(new Uint32Array(indicesArray), 1),
  );
  geometry.computeVertexNormals();

  return geometry;
}
